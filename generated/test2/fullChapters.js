// Generated by Adaptive Learning Curriculum Generator
// Topic: React Development
// Generated: 2026-01-09T02:49:26.481Z

export const fullChapterContent = {
  "1": {
    "sections": [
      {
        "title": "Functional Components & Custom Hooks",
        "content": "### Functional Components & Custom Hooks\n\nFunctional components have become the foundation of modern React development, offering cleaner syntax and powerful capabilities through hooks. Understanding advanced patterns helps create maintainable, reusable code.\n\n**Advanced Functional Component Patterns**\n\nFunctional components excel at separating concerns and promoting reusability:\n\n```jsx\nconst UserProfile = ({ userId, onEdit }) => {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    fetchUser(userId).then(userData => {\n      setUser(userData);\n      setLoading(false);\n    });\n  }, [userId]);\n  \n  if (loading) return <LoadingSpinner />;\n  \n  return (\n    <div className=\"user-profile\">\n      <h2>{user.name}</h2>\n      <button onClick={() => onEdit(user)}>Edit Profile</button>\n    </div>\n  );\n};\n```\n\n**Creating Custom Hooks**\n\nCustom hooks extract complex logic into reusable functions:\n\n```jsx\nconst useApi = (url) => {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        const response = await fetch(url);\n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    fetchData();\n  }, [url]);\n  \n  return { data, loading, error };\n};\n\n// Usage\nconst ProductList = () => {\n  const { data: products, loading, error } = useApi('/api/products');\n  \n  if (loading) return <div>Loading products...</div>;\n  if (error) return <div>Error: {error}</div>;\n  \n  return (\n    <ul>\n      {products.map(product => (\n        <li key={product.id}>{product.name}</li>\n      ))}\n    </ul>\n  );\n};\n```\n\nüí° **Best Practice**: Custom hooks should start with \"use\" and encapsulate related state and effects together.\n\nüéì **Key Benefits**:\n- Logic reusability across components\n- Easier testing of isolated functionality\n- Cleaner component code\n- Better separation of concerns"
      },
      {
        "title": "State Management Strategies",
        "content": "### State Management Strategies\n\nChoosing the right state management approach is crucial for application scalability and maintainability. Different strategies serve different purposes and complexity levels.\n\n**useState for Local State**\n\nPerfect for component-specific state that doesn't need sharing:\n\n```jsx\nconst Counter = () => {\n  const [count, setCount] = useState(0);\n  const [step, setStep] = useState(1);\n  \n  const increment = () => setCount(prev => prev + step);\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <input \n        type=\"number\" \n        value={step} \n        onChange={(e) => setStep(Number(e.target.value))} \n      />\n      <button onClick={increment}>Increment by {step}</button>\n    </div>\n  );\n};\n```\n\n**useReducer for Complex State Logic**\n\nIdeal when state updates depend on previous state or involve multiple sub-values:\n\n```jsx\nconst initialState = { items: [], total: 0, loading: false };\n\nconst cartReducer = (state, action) => {\n  switch (action.type) {\n    case 'ADD_ITEM':\n      const newItems = [...state.items, action.payload];\n      return {\n        ...state,\n        items: newItems,\n        total: newItems.reduce((sum, item) => sum + item.price, 0)\n      };\n    case 'SET_LOADING':\n      return { ...state, loading: action.payload };\n    default:\n      return state;\n  }\n};\n\nconst ShoppingCart = () => {\n  const [state, dispatch] = useReducer(cartReducer, initialState);\n  \n  const addItem = (item) => {\n    dispatch({ type: 'ADD_ITEM', payload: item });\n  };\n  \n  return (\n    <div>\n      <p>Total: ${state.total}</p>\n      {state.items.map(item => <div key={item.id}>{item.name}</div>)}\n    </div>\n  );\n};\n```\n\n**Context API for Global State**\n\nShare state across multiple components without prop drilling:\n\n```jsx\nconst ThemeContext = createContext();\n\nconst ThemeProvider = ({ children }) => {\n  const [theme, setTheme] = useState('light');\n  \n  const toggleTheme = () => {\n    setTheme(prev => prev === 'light' ? 'dark' : 'light');\n  };\n  \n  return (\n    <ThemeContext.Provider value={{ theme, toggleTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n};\n```\n\n‚ö†Ô∏è **When to Use Each**:\n\n| Strategy | Use Case | Example |\n|----------|----------|---------|\n| useState | Simple, local state | Form inputs, toggles |\n| useReducer | Complex state logic | Shopping cart, form validation |\n| Context API | Global state, theming | User authentication, app settings |\n\nüîß **Performance Tip**: Avoid putting frequently changing values in Context to prevent unnecessary re-renders."
      },
      {
        "title": "Component Composition Patterns",
        "content": "### Component Composition Patterns\n\nComponent composition patterns provide flexible ways to share code and create reusable UI elements. These patterns promote loose coupling and high reusability.\n\n**Render Props Pattern**\n\nShares code between components using a prop whose value is a function:\n\n```jsx\nconst DataFetcher = ({ url, render }) => {\n  const { data, loading, error } = useApi(url);\n  \n  return render({ data, loading, error });\n};\n\n// Usage\nconst ProductPage = () => (\n  <DataFetcher \n    url=\"/api/products\" \n    render={({ data, loading, error }) => {\n      if (loading) return <Spinner />;\n      if (error) return <ErrorMessage error={error} />;\n      return <ProductList products={data} />;\n    }}\n  />\n);\n```\n\n**Higher-Order Components (HOCs)**\n\nWrap components to add additional functionality:\n\n```jsx\nconst withAuth = (WrappedComponent) => {\n  return (props) => {\n    const { user, loading } = useAuth();\n    \n    if (loading) return <LoadingSpinner />;\n    if (!user) return <LoginForm />;\n    \n    return <WrappedComponent {...props} user={user} />;\n  };\n};\n\n// Usage\nconst Dashboard = ({ user }) => (\n  <div>Welcome, {user.name}!</div>\n);\n\nconst ProtectedDashboard = withAuth(Dashboard);\n```\n\n**Compound Component Pattern**\n\nCreate components that work together as a cohesive unit:\n\n```jsx\nconst Modal = ({ children, isOpen, onClose }) => {\n  if (!isOpen) return null;\n  \n  return (\n    <div className=\"modal-backdrop\" onClick={onClose}>\n      <div className=\"modal-content\" onClick={e => e.stopPropagation()}>\n        {children}\n      </div>\n    </div>\n  );\n};\n\nModal.Header = ({ children }) => (\n  <div className=\"modal-header\">{children}</div>\n);\n\nModal.Body = ({ children }) => (\n  <div className=\"modal-body\">{children}</div>\n);\n\nModal.Footer = ({ children }) => (\n  <div className=\"modal-footer\">{children}</div>\n);\n\n// Usage\nconst App = () => {\n  const [showModal, setShowModal] = useState(false);\n  \n  return (\n    <Modal isOpen={showModal} onClose={() => setShowModal(false)}>\n      <Modal.Header>\n        <h2>Confirm Action</h2>\n      </Modal.Header>\n      <Modal.Body>\n        <p>Are you sure you want to proceed?</p>\n      </Modal.Body>\n      <Modal.Footer>\n        <button onClick={() => setShowModal(false)}>Cancel</button>\n        <button onClick={handleConfirm}>Confirm</button>\n      </Modal.Footer>\n    </Modal>\n  );\n};\n```\n\nüíé **Pattern Comparison**:\n\n| Pattern | Flexibility | Complexity | Best For |\n|---------|-------------|------------|----------|\n| Render Props | High | Medium | Dynamic rendering logic |\n| HOCs | Medium | Medium | Cross-cutting concerns |\n| Compound Components | Medium | Low | Related UI components |"
      },
      {
        "title": "Performance Optimization Techniques",
        "content": "### Performance Optimization Techniques\n\nOptimizing React applications requires strategic use of built-in tools and patterns. Proper optimization prevents unnecessary re-renders and improves user experience.\n\n**React.memo for Component Memoization**\n\nPrevents re-renders when props haven't changed:\n\n```jsx\nconst ExpensiveComponent = React.memo(({ data, onAction }) => {\n  console.log('ExpensiveComponent rendered');\n  \n  return (\n    <div>\n      {data.map(item => (\n        <div key={item.id} onClick={() => onAction(item)}>\n          {item.name}\n        </div>\n      ))}\n    </div>\n  );\n});\n\n// Custom comparison for complex props\nconst OptimizedComponent = React.memo(\n  ({ user, settings }) => {\n    return <UserProfile user={user} settings={settings} />;\n  },\n  (prevProps, nextProps) => {\n    return prevProps.user.id === nextProps.user.id &&\n           prevProps.settings.theme === nextProps.settings.theme;\n  }\n);\n```\n\n**useMemo and useCallback Hooks**\n\nMemoize expensive calculations and function references:\n\n```jsx\nconst ProductList = ({ products, searchTerm, onProductClick }) => {\n  // Memoize expensive filtering operation\n  const filteredProducts = useMemo(() => {\n    return products.filter(product => \n      product.name.toLowerCase().includes(searchTerm.toLowerCase())\n    );\n  }, [products, searchTerm]);\n  \n  // Memoize callback to prevent child re-renders\n  const handleProductClick = useCallback((product) => {\n    onProductClick(product.id);\n  }, [onProductClick]);\n  \n  return (\n    <div>\n      {filteredProducts.map(product => (\n        <ProductCard \n          key={product.id}\n          product={product}\n          onClick={handleProductClick}\n        />\n      ))}\n    </div>\n  );\n};\n```\n\n**Lazy Loading with React.lazy**\n\nLoad components only when needed:\n\n```jsx\nconst LazyDashboard = React.lazy(() => import('./Dashboard'));\nconst LazySettings = React.lazy(() => import('./Settings'));\n\nconst App = () => {\n  const [currentView, setCurrentView] = useState('home');\n  \n  return (\n    <div>\n      <nav>\n        <button onClick={() => setCurrentView('dashboard')}>Dashboard</button>\n        <button onClick={() => setCurrentView('settings')}>Settings</button>\n      </nav>\n      \n      <Suspense fallback={<div>Loading...</div>}>\n        {currentView === 'dashboard' && <LazyDashboard />}\n        {currentView === 'settings' && <LazySettings />}\n      </Suspense>\n    </div>\n  );\n};\n```\n\n**Optimizing Context Usage**\n\nSplit contexts to minimize re-renders:\n\n```jsx\n// Instead of one large context\nconst AppStateContext = createContext();\nconst AppActionsContext = createContext();\n\nconst AppProvider = ({ children }) => {\n  const [state, dispatch] = useReducer(appReducer, initialState);\n  \n  const actions = useMemo(() => ({\n    updateUser: (user) => dispatch({ type: 'UPDATE_USER', payload: user }),\n    setTheme: (theme) => dispatch({ type: 'SET_THEME', payload: theme })\n  }), []);\n  \n  return (\n    <AppStateContext.Provider value={state}>\n      <AppActionsContext.Provider value={actions}>\n        {children}\n      </AppActionsContext.Provider>\n    </AppStateContext.Provider>\n  );\n};\n```\n\n‚úÖ **Optimization Checklist**:\n- Use React.memo for expensive components\n- Memoize callbacks with useCallback\n- Cache expensive calculations with useMemo\n- Implement lazy loading for large components\n- Split Context providers by update frequency\n\n‚ö†Ô∏è **Avoid Over-Optimization**: Profile first, optimize second. Premature optimization can make code harder to maintain."
      }
    ]
  },
  "2": {
    "sections": [
      {
        "title": "Advanced Hook Patterns",
        "content": "### Advanced Hook Patterns\n\nMastering advanced hooks unlocks powerful patterns for complex state management and precise DOM interactions.\n\n**useReducer for Complex State Logic**\n\nüéì **When to Use:** Replace useState when state logic becomes complex or involves multiple sub-values.\n\n```javascript\nconst initialState = { count: 0, loading: false, error: null };\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'INCREMENT':\n      return { ...state, count: state.count + 1 };\n    case 'SET_LOADING':\n      return { ...state, loading: action.payload };\n    case 'SET_ERROR':\n      return { ...state, error: action.payload, loading: false };\n    default:\n      throw new Error();\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  \n  const handleIncrement = () => {\n    dispatch({ type: 'SET_LOADING', payload: true });\n    setTimeout(() => {\n      dispatch({ type: 'INCREMENT' });\n      dispatch({ type: 'SET_LOADING', payload: false });\n    }, 1000);\n  };\n}\n```\n\n**useImperativeHandle for Ref Control**\n\nüí° **Purpose:** Customize the instance value exposed to parent components when using ref.\n\n```javascript\nconst FancyInput = forwardRef((props, ref) => {\n  const inputRef = useRef();\n  \n  useImperativeHandle(ref, () => ({\n    focus: () => inputRef.current.focus(),\n    clear: () => inputRef.current.value = '',\n    getValue: () => inputRef.current.value\n  }));\n  \n  return <input ref={inputRef} />;\n});\n```\n\n**useLayoutEffect for DOM Measurements**\n\n‚ö†Ô∏è **Critical:** Runs synchronously after DOM mutations but before browser paint.\n\n```javascript\nfunction Tooltip() {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n  const tooltipRef = useRef();\n  \n  useLayoutEffect(() => {\n    const rect = tooltipRef.current.getBoundingClientRect();\n    setPosition({ x: rect.width, y: rect.height });\n  }, []);\n}\n```\n\n‚úÖ **Best Practice:** Use useLayoutEffect sparingly‚Äîonly when you need synchronous DOM measurements to prevent visual flickering."
      },
      {
        "title": "Memoization and React.memo",
        "content": "### Memoization and React.memo\n\nStrategic memoization prevents unnecessary re-renders and expensive calculations, dramatically improving application performance.\n\n**React.memo for Component Memoization**\n\nüéì **Concept:** Wraps components to skip renders when props haven't changed.\n\n```javascript\nconst ExpensiveChild = React.memo(({ data, onUpdate }) => {\n  console.log('ExpensiveChild rendered');\n  return (\n    <div>\n      {data.map(item => <div key={item.id}>{item.name}</div>)}\n      <button onClick={onUpdate}>Update</button>\n    </div>\n  );\n});\n\n// Custom comparison function\nconst SmartChild = React.memo(({ user, settings }) => {\n  return <div>{user.name} - {settings.theme}</div>;\n}, (prevProps, nextProps) => {\n  return prevProps.user.id === nextProps.user.id &&\n         prevProps.settings.theme === nextProps.settings.theme;\n});\n```\n\n**useMemo for Expensive Calculations**\n\nüí° **Use Case:** Cache expensive computations between renders.\n\n```javascript\nfunction DataProcessor({ items, filters }) {\n  const processedData = useMemo(() => {\n    console.log('Processing data...'); // Only logs when dependencies change\n    return items\n      .filter(item => filters.includes(item.category))\n      .sort((a, b) => b.score - a.score)\n      .slice(0, 100);\n  }, [items, filters]);\n  \n  return <div>{processedData.map(item => <Item key={item.id} {...item} />)}</div>;\n}\n```\n\n**useCallback for Function Memoization**\n\nüîß **Purpose:** Prevents child re-renders caused by new function references.\n\n```javascript\nfunction Parent({ items }) {\n  const [filter, setFilter] = useState('');\n  \n  const handleItemClick = useCallback((id) => {\n    console.log('Item clicked:', id);\n    // Expensive operation here\n  }, []); // Empty deps = function never changes\n  \n  const filteredItems = useMemo(() => \n    items.filter(item => item.name.includes(filter))\n  , [items, filter]);\n  \n  return (\n    <div>\n      <input onChange={e => setFilter(e.target.value)} />\n      {filteredItems.map(item => \n        <MemoizedItem key={item.id} item={item} onClick={handleItemClick} />\n      )}\n    </div>\n  );\n}\n```\n\n‚ö†Ô∏è **Warning:** Don't memoize everything‚Äîprofiling should guide optimization decisions."
      },
      {
        "title": "Performance Profiling Tools",
        "content": "### Performance Profiling Tools\n\nEffective performance optimization starts with measurement. React DevTools Profiler and browser tools provide insights into rendering bottlenecks.\n\n**React DevTools Profiler**\n\nüîß **Setup:** Install React DevTools extension and wrap your app with Profiler.\n\n```javascript\nimport { Profiler } from 'react';\n\nfunction onRenderCallback(id, phase, actualDuration) {\n  console.log('Component:', id, 'Phase:', phase, 'Duration:', actualDuration);\n}\n\nfunction App() {\n  return (\n    <Profiler id=\"App\" onRender={onRenderCallback}>\n      <Header />\n      <MainContent />\n      <Footer />\n    </Profiler>\n  );\n}\n```\n\n**Profiler Analysis Workflow**\n\nüí° **Step-by-step process:**\n\n1. **Record interactions** - Click \"Start profiling\" and perform user actions\n2. **Identify expensive renders** - Look for components with high commit duration\n3. **Check render frequency** - Find components re-rendering unnecessarily\n4. **Analyze props changes** - See what props actually changed between renders\n\n**Browser Performance Tools**\n\nüéì **Chrome DevTools Performance Tab:**\n\n```javascript\n// Add performance marks for custom measurement\nfunction ExpensiveComponent() {\n  useEffect(() => {\n    performance.mark('expensive-component-start');\n    // Expensive operation\n    setTimeout(() => {\n      performance.mark('expensive-component-end');\n      performance.measure(\n        'expensive-component-duration',\n        'expensive-component-start',\n        'expensive-component-end'\n      );\n    }, 0);\n  }, []);\n}\n```\n\n**Performance Monitoring in Production**\n\n```javascript\n// Custom performance monitoring hook\nfunction usePerformanceMonitor(componentName) {\n  useEffect(() => {\n    const startTime = performance.now();\n    return () => {\n      const endTime = performance.now();\n      if (endTime - startTime > 16) { // Longer than one frame\n        console.warn(`${componentName} took ${endTime - startTime}ms to render`);\n      }\n    };\n  });\n}\n```\n\n‚úÖ **Key Metrics to Monitor:**\n- **First Contentful Paint (FCP)** - When first content appears\n- **Time to Interactive (TTI)** - When page becomes fully interactive\n- **Component render duration** - Individual component performance\n- **Bundle size impact** - How code splitting affects loading"
      },
      {
        "title": "Side Effect Management",
        "content": "### Side Effect Management\n\nMastering useEffect patterns ensures reliable side effect handling, proper cleanup, and optimal async operations management.\n\n**Complex Effect Dependencies**\n\nüéì **Pattern:** Managing multiple dependencies and conditional effects.\n\n```javascript\nfunction UserProfile({ userId, refreshTrigger }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(false);\n  \n  useEffect(() => {\n    if (!userId) return; // Guard clause\n    \n    let cancelled = false;\n    setLoading(true);\n    \n    fetchUser(userId)\n      .then(userData => {\n        if (!cancelled) {\n          setUser(userData);\n          setLoading(false);\n        }\n      })\n      .catch(error => {\n        if (!cancelled) {\n          console.error('Failed to fetch user:', error);\n          setLoading(false);\n        }\n      });\n    \n    return () => { cancelled = true; }; // Cleanup\n  }, [userId, refreshTrigger]);\n}\n```\n\n**Advanced Cleanup Patterns**\n\nüí° **WebSocket Management:**\n\n```javascript\nfunction useWebSocket(url, options = {}) {\n  const [data, setData] = useState(null);\n  const [connectionStatus, setConnectionStatus] = useState('Disconnected');\n  \n  useEffect(() => {\n    if (!url) return;\n    \n    const ws = new WebSocket(url);\n    setConnectionStatus('Connecting');\n    \n    ws.onopen = () => setConnectionStatus('Connected');\n    ws.onmessage = (event) => setData(JSON.parse(event.data));\n    ws.onclose = () => setConnectionStatus('Disconnected');\n    ws.onerror = () => setConnectionStatus('Error');\n    \n    return () => {\n      ws.close();\n      setConnectionStatus('Disconnected');\n    };\n  }, [url]);\n  \n  return { data, connectionStatus };\n}\n```\n\n**Debounced Effects**\n\nüîß **Search Implementation:**\n\n```javascript\nfunction SearchResults({ query }) {\n  const [results, setResults] = useState([]);\n  const [isSearching, setIsSearching] = useState(false);\n  \n  useEffect(() => {\n    if (!query.trim()) {\n      setResults([]);\n      return;\n    }\n    \n    setIsSearching(true);\n    const timeoutId = setTimeout(() => {\n      searchAPI(query)\n        .then(setResults)\n        .finally(() => setIsSearching(false));\n    }, 500); // 500ms debounce\n    \n    return () => clearTimeout(timeoutId);\n  }, [query]);\n}\n```\n\n‚ö†Ô∏è **Common Pitfalls:**\n- **Missing cleanup** - Always clean up subscriptions, timers, and async operations\n- **Stale closures** - Use functional updates or refs for current values\n- **Infinite loops** - Ensure effect dependencies are stable"
      },
      {
        "title": "Code Splitting and Lazy Loading",
        "content": "### Code Splitting and Lazy Loading\n\nOptimize bundle loading with strategic code splitting, React.lazy, and Suspense to improve initial page load performance.\n\n**React.lazy and Suspense Basics**\n\nüéì **Component-Level Splitting:**\n\n```javascript\nimport { lazy, Suspense } from 'react';\n\n// Lazy load heavy components\nconst Dashboard = lazy(() => import('./Dashboard'));\nconst UserProfile = lazy(() => import('./UserProfile'));\nconst Analytics = lazy(() => import('./Analytics'));\n\nfunction App() {\n  return (\n    <Router>\n      <Suspense fallback={<div>Loading page...</div>}>\n        <Routes>\n          <Route path=\"/dashboard\" element={<Dashboard />} />\n          <Route path=\"/profile\" element={<UserProfile />} />\n          <Route path=\"/analytics\" element={<Analytics />} />\n        </Routes>\n      </Suspense>\n    </Router>\n  );\n}\n```\n\n**Advanced Loading States**\n\nüí° **Custom Loading Components:**\n\n```javascript\nconst LoadingSpinner = () => (\n  <div className=\"flex justify-center items-center h-64\">\n    <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500\" />\n    <span className=\"ml-3\">Loading component...</span>\n  </div>\n);\n\nconst ErrorBoundary = ({ children }) => {\n  return (\n    <ErrorBoundary fallback={<div>Something went wrong while loading.</div>}>\n      <Suspense fallback={<LoadingSpinner />}>\n        {children}\n      </Suspense>\n    </ErrorBoundary>\n  );\n};\n```\n\n**Dynamic Import Patterns**\n\nüîß **Conditional Loading:**\n\n```javascript\nfunction FeatureToggle({ feature, children }) {\n  const [Component, setComponent] = useState(null);\n  const [loading, setLoading] = useState(false);\n  \n  const loadComponent = async () => {\n    if (!Component && feature.enabled) {\n      setLoading(true);\n      try {\n        const module = await import(`./features/${feature.name}`);\n        setComponent(() => module.default);\n      } catch (error) {\n        console.error('Failed to load feature:', error);\n      } finally {\n        setLoading(false);\n      }\n    }\n  };\n  \n  useEffect(() => {\n    loadComponent();\n  }, [feature.enabled]);\n  \n  if (loading) return <div>Loading feature...</div>;\n  if (Component) return <Component />;\n  return children || null;\n}\n```\n\n**Bundle Optimization Strategies**\n\nüíé **Webpack Bundle Analysis:**\n\n```javascript\n// webpack.config.js optimization\nmodule.exports = {\n  optimization: {\n    splitChunks: {\n      chunks: 'all',\n      cacheGroups: {\n        vendor: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          name: 'vendors',\n          chunks: 'all',\n        },\n        common: {\n          name: 'common',\n          minChunks: 2,\n          chunks: 'all',\n        },\n      },\n    },\n  },\n};\n```\n\n‚úÖ **Best Practices:**\n- **Route-based splitting** - Split at route boundaries for optimal UX\n- **Feature-based splitting** - Group related functionality together\n- **Preload critical routes** - Use `<link rel=\"preload\">` for likely next pages\n- **Monitor bundle sizes** - Use tools like webpack-bundle-analyzer"
      }
    ]
  },
  "3": {
    "sections": [
      {
        "title": "Component Testing with Testing Library",
        "content": "### Component Testing with Testing Library\n\nReact Testing Library focuses on testing components from a user's perspective, emphasizing behavior over implementation details. This approach creates more maintainable and meaningful tests.\n\n**Setting Up Testing Library**\n\n```javascript\n// Install dependencies\nnpm install --save-dev @testing-library/react @testing-library/jest-dom\n\n// setupTests.js\nimport '@testing-library/jest-dom';\n```\n\n**Basic Component Testing**\n\n```javascript\n// UserProfile.test.js\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport UserProfile from './UserProfile';\n\ntest('displays user information correctly', () => {\n  const user = { name: 'John Doe', email: 'john@example.com' };\n  render(<UserProfile user={user} />);\n  \n  expect(screen.getByText('John Doe')).toBeInTheDocument();\n  expect(screen.getByText('john@example.com')).toBeInTheDocument();\n});\n\ntest('handles edit button click', () => {\n  const mockOnEdit = jest.fn();\n  render(<UserProfile user={user} onEdit={mockOnEdit} />);\n  \n  fireEvent.click(screen.getByRole('button', { name: /edit/i }));\n  expect(mockOnEdit).toHaveBeenCalledWith(user.id);\n});\n```\n\n**Form Testing**\n\n```javascript\ntest('submits form with correct data', async () => {\n  const mockSubmit = jest.fn();\n  render(<ContactForm onSubmit={mockSubmit} />);\n  \n  await user.type(screen.getByLabelText(/name/i), 'Jane Smith');\n  await user.type(screen.getByLabelText(/email/i), 'jane@test.com');\n  await user.click(screen.getByRole('button', { name: /submit/i }));\n  \n  expect(mockSubmit).toHaveBeenCalledWith({\n    name: 'Jane Smith',\n    email: 'jane@test.com'\n  });\n});\n```\n\nüéì **Best Practices:**\n- Use semantic queries (getByRole, getByLabelText)\n- Test user interactions, not implementation\n- Write descriptive test names\n- Focus on what users see and do\n\nüí° **Testing Library encourages accessible markup by making it easier to test components that follow accessibility best practices.**"
      },
      {
        "title": "Advanced Testing Patterns",
        "content": "### Advanced Testing Patterns\n\nAdvanced testing patterns help handle complex scenarios like API calls, custom hooks, and component integration, ensuring comprehensive test coverage.\n\n**Mocking API Calls**\n\n```javascript\n// Using MSW (Mock Service Worker)\nimport { rest } from 'msw';\nimport { setupServer } from 'msw/node';\n\nconst server = setupServer(\n  rest.get('/api/users', (req, res, ctx) => {\n    return res(\n      ctx.json([\n        { id: 1, name: 'John Doe' },\n        { id: 2, name: 'Jane Smith' }\n      ])\n    );\n  })\n);\n\nbeforeAll(() => server.listen());\nafterEach(() => server.resetHandlers());\nafterAll(() => server.close());\n```\n\n**Testing Custom Hooks**\n\n```javascript\nimport { renderHook, act } from '@testing-library/react';\nimport { useCounter } from './useCounter';\n\ntest('useCounter increments correctly', () => {\n  const { result } = renderHook(() => useCounter(0));\n  \n  expect(result.current.count).toBe(0);\n  \n  act(() => {\n    result.current.increment();\n  });\n  \n  expect(result.current.count).toBe(1);\n});\n\n// Testing hooks with context\ntest('useAuth returns user when authenticated', () => {\n  const wrapper = ({ children }) => (\n    <AuthProvider initialUser={mockUser}>\n      {children}\n    </AuthProvider>\n  );\n  \n  const { result } = renderHook(() => useAuth(), { wrapper });\n  expect(result.current.user).toEqual(mockUser);\n});\n```\n\n**Async Testing Patterns**\n\n```javascript\ntest('loads and displays data', async () => {\n  render(<UserList />);\n  \n  // Wait for loading to complete\n  await waitForElementToBeRemoved(screen.getByText(/loading/i));\n  \n  expect(screen.getByText('John Doe')).toBeInTheDocument();\n  expect(screen.getByText('Jane Smith')).toBeInTheDocument();\n});\n\ntest('handles error states', async () => {\n  server.use(\n    rest.get('/api/users', (req, res, ctx) => {\n      return res(ctx.status(500));\n    })\n  );\n  \n  render(<UserList />);\n  expect(await screen.findByText(/error occurred/i)).toBeInTheDocument();\n});\n```\n\nüîß **Advanced Testing Tools:**\n- **MSW**: Realistic API mocking\n- **Testing Library User Event**: More realistic user interactions\n- **React Hook Testing Library**: Dedicated hook testing utilities\n\n‚ö†Ô∏è **Remember**: Mock external dependencies, not your own code. Focus on testing behavior, not implementation details."
      },
      {
        "title": "Production Build Optimization",
        "content": "### Production Build Optimization\n\nOptimizing React applications for production involves bundle optimization, environment configuration, and performance enhancements to deliver fast, efficient applications.\n\n**Webpack Bundle Analysis**\n\n```javascript\n// Install bundle analyzer\nnpm install --save-dev webpack-bundle-analyzer\n\n// package.json scripts\n{\n  \"scripts\": {\n    \"analyze\": \"npm run build && npx webpack-bundle-analyzer build/static/js/*.js\",\n    \"build:analyze\": \"ANALYZE=true npm run build\"\n  }\n}\n\n// webpack.config.js\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\nmodule.exports = {\n  plugins: [\n    process.env.ANALYZE && new BundleAnalyzerPlugin()\n  ].filter(Boolean)\n};\n```\n\n**Code Splitting Strategies**\n\n```javascript\n// Route-based splitting\nimport { lazy, Suspense } from 'react';\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\n\nconst Home = lazy(() => import('./pages/Home'));\nconst Dashboard = lazy(() => import('./pages/Dashboard'));\nconst Profile = lazy(() => import('./pages/Profile'));\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Suspense fallback={<div>Loading...</div>}>\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/dashboard\" element={<Dashboard />} />\n          <Route path=\"/profile\" element={<Profile />} />\n        </Routes>\n      </Suspense>\n    </BrowserRouter>\n  );\n}\n\n// Component-based splitting\nconst HeavyChart = lazy(() => \n  import('./HeavyChart').then(module => ({ default: module.HeavyChart }))\n);\n```\n\n**Environment Configuration**\n\n```javascript\n// .env.production\nREACT_APP_API_URL=https://api.production.com\nREACT_APP_SENTRY_DSN=your-production-sentry-dsn\nGENERATE_SOURCEMAP=false\n\n// config/environment.js\nconst config = {\n  development: {\n    API_URL: process.env.REACT_APP_API_URL || 'http://localhost:3001',\n    DEBUG: true\n  },\n  production: {\n    API_URL: process.env.REACT_APP_API_URL,\n    DEBUG: false\n  }\n};\n\nexport default config[process.env.NODE_ENV];\n```\n\n**Build Optimization Techniques**\n\n```javascript\n// Tree shaking with ES modules\nimport { debounce } from 'lodash-es'; // ‚úÖ Tree-shakable\n// import _ from 'lodash'; // ‚ùå Imports entire library\n\n// Image optimization\nimport webpImage from './hero.webp';\nimport fallbackImage from './hero.jpg';\n\nconst OptimizedImage = () => (\n  <picture>\n    <source srcSet={webpImage} type=\"image/webp\" />\n    <img src={fallbackImage} alt=\"Hero\" />\n  </picture>\n);\n```\n\nüíé **Production Checklist:**\n- ‚úÖ Enable gzip/brotli compression\n- ‚úÖ Implement service worker caching\n- ‚úÖ Optimize images and assets\n- ‚úÖ Remove console.logs and debug code\n- ‚úÖ Set up proper CSP headers\n\nüîß **Build Tools**: Create React App, Vite, or custom Webpack configurations provide different optimization strategies."
      },
      {
        "title": "CI/CD and Deployment Strategies",
        "content": "### CI/CD and Deployment Strategies\n\nAutomated CI/CD pipelines ensure consistent, reliable deployments while maintaining code quality through automated testing and deployment processes.\n\n**GitHub Actions CI/CD Pipeline**\n\n```yaml\n# .github/workflows/ci-cd.yml\nname: CI/CD Pipeline\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n      \n      - name: Install dependencies\n        run: npm ci\n      \n      - name: Run tests\n        run: npm run test -- --coverage --watchAll=false\n      \n      - name: Run lint\n        run: npm run lint\n      \n      - name: Upload coverage\n        uses: codecov/codecov-action@v3\n\n  build-and-deploy:\n    needs: test\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'\n    \n    steps:\n      - uses: actions/checkout@v3\n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n      \n      - name: Install and build\n        run: |\n          npm ci\n          npm run build\n      \n      - name: Deploy to Netlify\n        uses: nwtgck/actions-netlify@v2\n        with:\n          publish-dir: './build'\n          production-branch: main\n        env:\n          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}\n          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}\n```\n\n**Docker Deployment**\n\n```dockerfile\n# Dockerfile\nFROM node:18-alpine as build\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci --only=production\nCOPY . .\nRUN npm run build\n\nFROM nginx:alpine\nCOPY --from=build /app/build /usr/share/nginx/html\nCOPY nginx.conf /etc/nginx/nginx.conf\nEXPOSE 80\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n```\n\n**Environment-Specific Deployments**\n\n```javascript\n// deployment/deploy.js\nconst environments = {\n  staging: {\n    apiUrl: 'https://api-staging.example.com',\n    deployTarget: 'staging-server'\n  },\n  production: {\n    apiUrl: 'https://api.example.com',\n    deployTarget: 'production-server'\n  }\n};\n\nconst deploy = async (env) => {\n  const config = environments[env];\n  \n  // Build with environment variables\n  process.env.REACT_APP_API_URL = config.apiUrl;\n  await exec('npm run build');\n  \n  // Deploy to target\n  await deployTo(config.deployTarget);\n};\n```\n\n**Deployment Strategies**\n\n| Strategy | Description | Use Case |\n|----------|-------------|----------|\n| **Blue-Green** | Two identical environments, switch traffic | Zero-downtime critical apps |\n| **Rolling** | Gradual replacement of instances | Standard production deploys |\n| **Canary** | Deploy to subset of users first | Risk mitigation |\n\nüöÄ **Popular Deployment Platforms:**\n- **Vercel**: Zero-config React deployments\n- **Netlify**: JAMstack-focused with form handling\n- **AWS Amplify**: Full-stack cloud deployment\n- **Heroku**: Container-based deployment\n\n‚úÖ **Deployment Best Practices:**\n- Use environment variables for configuration\n- Implement health checks\n- Set up automated rollbacks\n- Monitor deployment metrics"
      },
      {
        "title": "Production Monitoring and Debugging",
        "content": "### Production Monitoring and Debugging\n\nProduction monitoring and debugging tools help identify issues, track performance, and maintain application health in live environments.\n\n**Error Tracking with Sentry**\n\n```javascript\n// Install and configure Sentry\nnpm install @sentry/react @sentry/tracing\n\n// index.js\nimport * as Sentry from '@sentry/react';\nimport { BrowserTracing } from '@sentry/tracing';\n\nSentry.init({\n  dsn: process.env.REACT_APP_SENTRY_DSN,\n  environment: process.env.NODE_ENV,\n  integrations: [\n    new BrowserTracing(),\n  ],\n  tracesSampleRate: 0.1,\n  beforeSend(event) {\n    // Filter out development errors\n    if (process.env.NODE_ENV === 'development') {\n      return null;\n    }\n    return event;\n  }\n});\n\n// Error Boundary with Sentry\nimport { ErrorBoundary } from '@sentry/react';\n\nfunction App() {\n  return (\n    <ErrorBoundary fallback={ErrorFallback} showDialog>\n      <MyApp />\n    </ErrorBoundary>\n  );\n}\n```\n\n**Performance Monitoring**\n\n```javascript\n// Custom performance tracking\nconst trackPerformance = (name, fn) => {\n  return async (...args) => {\n    const start = performance.now();\n    const result = await fn(...args);\n    const duration = performance.now() - start;\n    \n    // Send to analytics\n    gtag('event', 'timing_complete', {\n      name,\n      value: Math.round(duration)\n    });\n    \n    return result;\n  };\n};\n\n// Web Vitals tracking\nimport { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';\n\nconst sendToAnalytics = (metric) => {\n  gtag('event', metric.name, {\n    event_category: 'Web Vitals',\n    value: Math.round(metric.value),\n    non_interaction: true\n  });\n};\n\ngetCLS(sendToAnalytics);\ngetFID(sendToAnalytics);\ngetFCP(sendToAnalytics);\ngetLCP(sendToAnalytics);\ngetTTFB(sendToAnalytics);\n```\n\n**Application Health Monitoring**\n\n```javascript\n// Custom monitoring hook\nimport { useEffect } from 'react';\n\nconst useAppMonitoring = () => {\n  useEffect(() => {\n    // Monitor memory usage\n    const checkMemory = () => {\n      if ('memory' in performance) {\n        const memory = performance.memory;\n        if (memory.usedJSHeapSize / memory.totalJSHeapSize > 0.9) {\n          Sentry.captureMessage('High memory usage detected', 'warning');\n        }\n      }\n    };\n\n    // Monitor network status\n    const handleOnline = () => {\n      Sentry.addBreadcrumb({\n        message: 'Network connection restored',\n        level: 'info'\n      });\n    };\n\n    const handleOffline = () => {\n      Sentry.captureMessage('Network connection lost', 'warning');\n    };\n\n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n    \n    const memoryInterval = setInterval(checkMemory, 30000);\n\n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n      clearInterval(memoryInterval);\n    };\n  }, []);\n};\n```\n\n**Debugging Tools Setup**\n\n```javascript\n// React DevTools profiler integration\nif (process.env.NODE_ENV === 'development') {\n  import('react-dom/profiling');\n  import('scheduler/tracing');\n}\n\n// Custom debugging utilities\nconst debugHelpers = {\n  logRenders: (componentName) => {\n    if (process.env.NODE_ENV === 'development') {\n      console.log(`${componentName} rendered at`, new Date().toISOString());\n    }\n  },\n  \n  logProps: (props) => {\n    if (process.env.NODE_ENV === 'development') {\n      console.table(props);\n    }\n  }\n};\n```\n\nüìä **Monitoring Dashboard Setup:**\n- **Grafana**: Custom dashboards for metrics\n- **New Relic**: Application performance monitoring\n- **DataDog**: Full-stack monitoring\n- **LogRocket**: Session replay and debugging\n\nüîç **Production Debugging Checklist:**\n- ‚úÖ Set up error tracking and alerts\n- ‚úÖ Monitor Core Web Vitals\n- ‚úÖ Track user interactions and flows\n- ‚úÖ Set up uptime monitoring\n- ‚úÖ Configure log aggregation\n\n‚ö†Ô∏è **Security Consideration**: Never log sensitive user data or expose API keys in client-side monitoring code."
      }
    ]
  }
};
