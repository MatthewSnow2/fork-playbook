// Generated by Adaptive Learning Curriculum Generator
// Topic: React Development
// Generated: 2026-01-09T02:49:26.480Z

export const chaptersData = [
  {
    "id": 1,
    "number": "01",
    "title": "Component Architecture & State Management",
    "subtitle": "Building scalable React applications with modern patterns",
    "icon": "fa-cogs",
    "color": "from-blue-600 to-blue-400",
    "duration": "45 min",
    "keyTakeaways": [
      "Master functional components and custom hooks patterns",
      "Implement effective state management strategies",
      "Design reusable component architectures",
      "Apply composition patterns for maintainable code"
    ],
    "overview": "Dive into advanced React component patterns and state management techniques. Learn how to architect scalable applications using functional components, custom hooks, and modern state management approaches including Context API and local state optimization.",
    "sections": [
      {
        "title": "Functional Components & Custom Hooks",
        "content": "Explore advanced functional component patterns and create reusable custom hooks for complex logic."
      },
      {
        "title": "State Management Strategies",
        "content": "Compare different state management approaches from useState to Context API and when to use each."
      },
      {
        "title": "Component Composition Patterns",
        "content": "Learn render props, higher-order components, and compound component patterns for flexible designs."
      },
      {
        "title": "Performance Optimization Techniques",
        "content": "Implement memoization, lazy loading, and other optimization strategies for better performance."
      }
    ],
    "exercises": [
      {
        "type": "practical",
        "title": "Build a Custom Hook Library",
        "description": "Create a collection of 3 custom hooks (useLocalStorage, useApi, useForm) with proper TypeScript types and error handling.",
        "points": 150
      },
      {
        "type": "design",
        "title": "Component Architecture Analysis",
        "description": "Analyze and redesign a poorly structured React component tree using composition patterns and proper state lifting.",
        "points": 100
      }
    ],
    "quiz": [
      {
        "question": "When should you use useCallback hook in React?",
        "options": [
          "To prevent unnecessary re-renders of child components that depend on the function",
          "To cache expensive calculations",
          "To manage component state",
          "To handle side effects"
        ],
        "correct": 0,
        "explanation": "useCallback is used to memoize functions, preventing child components from re-rendering when the function reference hasn't actually changed."
      },
      {
        "question": "Which pattern is best for sharing data between deeply nested components?",
        "options": [
          "Prop drilling",
          "Higher-order components",
          "Context API",
          "Redux only"
        ],
        "correct": 2,
        "explanation": "Context API is specifically designed to share data across component trees without prop drilling, making it ideal for deeply nested components."
      },
      {
        "question": "What is the main advantage of compound components pattern?",
        "options": [
          "Better performance",
          "Flexible and declarative API",
          "Smaller bundle size",
          "Easier testing"
        ],
        "correct": 1,
        "explanation": "Compound components provide a flexible and declarative API where parent and child components work together seamlessly, similar to HTML select/option elements."
      }
    ],
    "reflection": "How can you refactor an existing component in your current project to use more modern React patterns? What state management approach would work best for your team's needs?"
  },
  {
    "id": 2,
    "number": "02",
    "title": "Advanced Hooks & Performance",
    "subtitle": "Mastering React's advanced features for optimal applications",
    "icon": "fa-microscope",
    "color": "from-green-600 to-green-400",
    "duration": "45 min",
    "keyTakeaways": [
      "Leverage advanced hooks like useReducer and useImperativeHandle",
      "Implement effective memoization strategies",
      "Profile and optimize React application performance",
      "Handle complex side effects and cleanup patterns"
    ],
    "overview": "Master React's advanced hooks and performance optimization techniques. Learn to use useReducer for complex state logic, implement proper memoization with useMemo and React.memo, and profile your applications for optimal performance.",
    "sections": [
      {
        "title": "Advanced Hook Patterns",
        "content": "Deep dive into useReducer, useImperativeHandle, and useLayoutEffect for complex scenarios."
      },
      {
        "title": "Memoization and React.memo",
        "content": "Implement strategic memoization using useMemo, useCallback, and React.memo to prevent unnecessary renders."
      },
      {
        "title": "Performance Profiling Tools",
        "content": "Use React DevTools Profiler and browser performance tools to identify and fix performance bottlenecks."
      },
      {
        "title": "Side Effect Management",
        "content": "Handle complex side effects, cleanup functions, and async operations with useEffect patterns."
      },
      {
        "title": "Code Splitting and Lazy Loading",
        "content": "Implement dynamic imports, React.lazy, and Suspense for optimized bundle loading strategies."
      }
    ],
    "exercises": [
      {
        "type": "practical",
        "title": "Performance Optimization Challenge",
        "description": "Optimize a provided React application with performance issues using profiling tools, memoization, and code splitting techniques.",
        "points": 200
      }
    ],
    "quiz": [
      {
        "question": "When is useReducer preferred over useState?",
        "options": [
          "When you have a single state value",
          "When you have complex state logic with multiple sub-values",
          "When you need better performance",
          "When working with forms only"
        ],
        "correct": 1,
        "explanation": "useReducer is preferred when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one in complex ways."
      },
      {
        "question": "What does React.memo do?",
        "options": [
          "Memoizes expensive calculations",
          "Prevents component from re-rendering if props haven't changed",
          "Caches API responses",
          "Optimizes hook performance"
        ],
        "correct": 1,
        "explanation": "React.memo is a higher-order component that memoizes the result and prevents re-rendering if the props haven't changed, similar to PureComponent for functional components."
      },
      {
        "question": "Which hook should you use for expensive calculations that depend on props?",
        "options": [
          "useCallback",
          "useEffect",
          "useMemo",
          "useReducer"
        ],
        "correct": 2,
        "explanation": "useMemo is used to memoize expensive calculations and only recalculates when its dependencies change, making it perfect for expensive computations based on props."
      },
      {
        "question": "What is the purpose of React.Suspense?",
        "options": [
          "Error handling",
          "State management",
          "Loading states for lazy-loaded components",
          "Performance monitoring"
        ],
        "correct": 2,
        "explanation": "React.Suspense provides a way to handle loading states declaratively, especially useful with React.lazy for code splitting and dynamic imports."
      }
    ],
    "reflection": "Which performance optimization techniques would have the biggest impact on your current React applications? How do you balance optimization with code maintainability?"
  },
  {
    "id": 3,
    "number": "03",
    "title": "Testing & Production Deployment",
    "subtitle": "Ensuring quality and reliability in React applications",
    "icon": "fa-check-circle",
    "color": "from-purple-600 to-purple-400",
    "duration": "45 min",
    "keyTakeaways": [
      "Implement comprehensive testing strategies for React components",
      "Master testing library patterns and best practices",
      "Configure production-ready build and deployment pipelines",
      "Monitor and debug React applications in production"
    ],
    "overview": "Learn to build production-ready React applications with comprehensive testing strategies and robust deployment practices. Master React Testing Library, implement CI/CD pipelines, and establish monitoring and error tracking for production applications.",
    "sections": [
      {
        "title": "Component Testing with Testing Library",
        "content": "Write effective unit and integration tests using React Testing Library with focus on user behavior."
      },
      {
        "title": "Advanced Testing Patterns",
        "content": "Implement mocking strategies, test custom hooks, and handle async operations in tests."
      },
      {
        "title": "Production Build Optimization",
        "content": "Configure webpack, implement environment-specific builds, and optimize bundle sizes for production."
      },
      {
        "title": "CI/CD and Deployment Strategies",
        "content": "Set up automated testing pipelines and deployment strategies for React applications."
      },
      {
        "title": "Production Monitoring and Debugging",
        "content": "Implement error tracking, performance monitoring, and debugging tools for production applications."
      }
    ],
    "exercises": [
      {
        "type": "practical",
        "title": "Complete Testing Suite Implementation",
        "description": "Create a comprehensive test suite for a React application including unit tests, integration tests, and custom hook testing with proper mocking.",
        "points": 180
      },
      {
        "type": "assessment",
        "title": "Production Deployment Pipeline",
        "description": "Design and document a complete CI/CD pipeline for a React application including testing, building, and deployment stages.",
        "points": 120
      }
    ],
    "quiz": [
      {
        "question": "What is the main philosophy behind React Testing Library?",
        "options": [
          "Test implementation details",
          "Test the way users interact with components",
          "Focus on code coverage only",
          "Test internal component state"
        ],
        "correct": 1,
        "explanation": "React Testing Library encourages testing components the way users interact with them, focusing on behavior rather than implementation details."
      },
      {
        "question": "Which query should you prefer when testing with React Testing Library?",
        "options": [
          "getByTestId",
          "getByClassName",
          "getByRole",
          "querySelector"
        ],
        "correct": 2,
        "explanation": "getByRole is preferred as it closely mimics how users and assistive technologies interact with elements, promoting accessibility and user-focused testing."
      },
      {
        "question": "What is tree shaking in the context of React production builds?",
        "options": [
          "Removing unused CSS",
          "Removing unused JavaScript code from bundles",
          "Optimizing image assets",
          "Compressing HTML files"
        ],
        "correct": 1,
        "explanation": "Tree shaking is a process that removes unused JavaScript code from your final bundle, reducing the bundle size and improving application performance."
      }
    ],
    "reflection": "How would you establish a testing culture in your development team? What metrics would you use to measure the quality and performance of your React applications in production?"
  }
];
