// Generated by Adaptive Learning Curriculum Generator
// Topic: Python Fundamentals
// Generated: 2026-01-09T02:43:25.854Z

export const fullChapterContent = {
  "1": {
    "sections": [
      {
        "title": "Python Installation and Setup",
        "content": "### Python Installation and Setup\n\nüîß **Getting Python on Your System**\n\nPython installation varies by operating system, but the process is straightforward:\n\n**Windows:**\n- Visit [python.org](https://python.org) and download the latest Python version\n- Run the installer and **check \"Add Python to PATH\"**\n- Verify installation: Open Command Prompt and type `python --version`\n\n**macOS:**\n- Use Homebrew: `brew install python3`\n- Or download from python.org\n- Verify: `python3 --version` in Terminal\n\n**Linux (Ubuntu/Debian):**\n```bash\nsudo apt update\nsudo apt install python3 python3-pip\n```\n\nüí° **Development Environment Options**\n\n1. **Python IDLE** (included with Python)\n   - Simple built-in editor\n   - Great for beginners\n   - Interactive shell included\n\n2. **Command Line/Terminal**\n   - Type `python` or `python3` to start interactive mode\n   - Exit with `exit()` or Ctrl+D\n\n3. **Popular IDEs:**\n   - **VS Code** with Python extension\n   - **PyCharm** (Community Edition is free)\n   - **Jupyter Notebooks** for data science\n\nüéì **Your First Python Session**\n\nOpen your terminal/command prompt and start Python:\n```python\n$ python\nPython 3.11.0 (main, Oct 24 2022, 18:26:48)\n>>> print(\"Hello, Python!\")\nHello, Python!\n>>> 2 + 3\n5\n>>> exit()\n```\n\n‚ö†Ô∏è **Common Setup Issues:**\n- \"Python not found\": PATH not set correctly\n- Multiple Python versions: Use `python3` explicitly\n- Permission errors: May need administrator/sudo access\n\n‚úÖ **Verification Checklist:**\n- [ ] Python interpreter starts without errors\n- [ ] Can execute simple commands\n- [ ] IDE/editor configured (optional but recommended)\n- [ ] Package manager (pip) working: `pip --version`"
      },
      {
        "title": "Basic Data Types and Variables",
        "content": "### Basic Data Types and Variables\n\nüéì **Understanding Python's Core Data Types**\n\nPython provides several built-in data types that form the foundation of all programs:\n\n**1. Integers (int)**\n```python\nage = 25\ntemperature = -10\nbig_number = 1000000\nprint(type(age))  # <class 'int'>\n```\n\n**2. Floating-Point Numbers (float)**\n```python\npi = 3.14159\nweight = 68.5\nscientific = 2.5e-3  # 0.0025\nprint(type(pi))  # <class 'float'>\n```\n\n**3. Strings (str)**\n```python\nname = \"Alice\"\nmessage = 'Hello, World!'\nmultiline = \"\"\"This is a\nmultiline string\"\"\"\nprint(type(name))  # <class 'str'>\n```\n\n**4. Booleans (bool)**\n```python\nis_student = True\nis_working = False\nprint(type(is_student))  # <class 'bool'>\n```\n\nüí° **Variable Assignment Rules**\n\n- Variables are created when first assigned\n- Names must start with letter or underscore\n- Case-sensitive: `Name` ‚â† `name`\n- Use descriptive names: `user_age` not `ua`\n\n```python\n# Good variable names\nstudent_count = 30\ntotal_price = 99.99\nis_valid = True\n\n# Multiple assignment\nx, y, z = 1, 2, 3\na = b = c = 0\n```\n\nüîß **Type Checking and Conversion**\n```python\n# Check type\nnumber = 42\nprint(type(number))  # <class 'int'>\n\n# Type conversion\nage_str = \"25\"\nage_int = int(age_str)  # String to integer\nprice_str = str(19.99)  # Float to string\nis_true = bool(1)      # Integer to boolean\n```\n\n‚ö†Ô∏è **Common Pitfalls:**\n- Trying to convert invalid strings: `int(\"hello\")` ‚Üí Error\n- Overwriting built-in names: Don't use `str = \"text\"`\n\nüíé **Best Practices:**\n- Use snake_case for variable names\n- Choose meaningful names\n- Initialize variables before use"
      },
      {
        "title": "Python Syntax and Structure",
        "content": "### Python Syntax and Structure\n\nüéì **Python's Unique Indentation System**\n\nUnlike many programming languages that use braces `{}`, Python uses **indentation** to define code blocks:\n\n```python\n# Correct indentation\nif 5 > 3:\n    print(\"Five is greater than three\")  # 4 spaces\n    print(\"This is also indented\")       # Same level\n\n# Nested indentation\nif True:\n    print(\"Outer block\")     # 4 spaces\n    if True:\n        print(\"Inner block\") # 8 spaces\n```\n\n‚ö†Ô∏è **Indentation Rules:**\n- Use **4 spaces** (recommended) or consistent tabs\n- All lines at the same level must have identical indentation\n- Mixing spaces and tabs causes errors\n\n**Common Indentation Error:**\n```python\nif 5 > 3:\nprint(\"This will cause an IndentationError!\")\n```\n\nüí° **Comments: Documenting Your Code**\n\n```python\n# This is a single-line comment\nname = \"Python\"  # End-of-line comment\n\n\"\"\"\nThis is a multi-line comment\n(also called a docstring when used in functions/classes)\nUse it for longer explanations\n\"\"\"\n\n# TODO: Add error handling here\nresult = 10 / 2\n```\n\nüîß **Code Organization Principles**\n\n**1. Line Continuation:**\n```python\n# Long lines can be split\ntotal = (first_number + \n         second_number + \n         third_number)\n\n# Or using backslash\nlong_string = \"This is a very long string that \" \\\n              \"continues on the next line\"\n```\n\n**2. Statement Separation:**\n```python\n# One statement per line (preferred)\nname = \"Alice\"\nage = 25\n\n# Multiple statements (not recommended)\nname = \"Alice\"; age = 25\n```\n\n**3. Blank Lines for Readability:**\n```python\n# Group related code\nfirst_name = \"John\"\nlast_name = \"Doe\"\n\n# Blank line separates different logic\ntotal_items = 10\nprice_per_item = 5.99\ntotal_cost = total_items * price_per_item\n```\n\n‚úÖ **Best Practices:**\n- Configure your editor to show whitespace\n- Use consistent indentation throughout\n- Add comments to explain complex logic\n- Keep lines under 80 characters when possible"
      },
      {
        "title": "Input and Output Operations",
        "content": "### Input and Output Operations\n\nüéì **Getting User Input with input()**\n\nThe `input()` function allows your programs to interact with users by accepting keyboard input:\n\n```python\n# Basic input\nname = input(\"What is your name? \")\nprint(\"Hello,\" + name + \"!\")\n\n# Input always returns a string\nage_str = input(\"How old are you? \")\nage = int(age_str)  # Convert to integer\nprint(f\"Next year you'll be {age + 1}\")\n```\n\nüí° **Input Type Conversion**\n\nSince `input()` always returns strings, convert when needed:\n\n```python\n# Getting numbers\nheight = float(input(\"Enter your height in meters: \"))\nweight = float(input(\"Enter your weight in kg: \"))\nbmi = weight / (height ** 2)\nprint(f\"Your BMI is: {bmi:.1f}\")\n\n# Getting boolean-like input\nresponse = input(\"Do you like Python? (yes/no): \")\nlikes_python = response.lower() == \"yes\"\nprint(f\"Likes Python: {likes_python}\")\n```\n\nüîß **Displaying Output with print()**\n\nThe `print()` function offers multiple ways to display information:\n\n**Basic Printing:**\n```python\nprint(\"Hello, World!\")\nprint(42)\nprint(3.14, \"is approximately pi\")\n```\n\n**String Formatting Options:**\n```python\nname = \"Alice\"\nage = 30\n\n# Method 1: Concatenation\nprint(\"Name: \" + name + \", Age: \" + str(age))\n\n# Method 2: f-strings (recommended)\nprint(f\"Name: {name}, Age: {age}\")\n\n# Method 3: .format() method\nprint(\"Name: {}, Age: {}\".format(name, age))\n\n# Method 4: % formatting (older style)\nprint(\"Name: %s, Age: %d\" % (name, age))\n```\n\n**Print Parameters:**\n```python\n# Custom separators\nprint(\"apple\", \"banana\", \"cherry\", sep=\", \")\n# Output: apple, banana, cherry\n\n# Custom end character\nprint(\"Loading\", end=\"...\")\nprint(\"Done!\")\n# Output: Loading...Done!\n\n# Print to different destinations\nprint(\"Error message\", file=sys.stderr)  # Requires: import sys\n```\n\n‚ö†Ô∏è **Common Input Pitfalls:**\n- Forgetting to convert input types\n- Not handling invalid input gracefully\n\nüíé **Interactive Program Example:**\n```python\nprint(\"=== Simple Calculator ===\")\nnum1 = float(input(\"Enter first number: \"))\nnum2 = float(input(\"Enter second number: \"))\nresult = num1 + num2\nprint(f\"{num1} + {num2} = {result}\")\n```"
      },
      {
        "title": "Basic Operators and Expressions",
        "content": "### Basic Operators and Expressions\n\nüéì **Arithmetic Operators**\n\nPython provides comprehensive arithmetic operations for mathematical calculations:\n\n```python\na = 10\nb = 3\n\nprint(f\"Addition: {a + b}\")        # 13\nprint(f\"Subtraction: {a - b}\")     # 7\nprint(f\"Multiplication: {a * b}\")  # 30\nprint(f\"Division: {a / b}\")        # 3.333...\nprint(f\"Floor Division: {a // b}\") # 3 (integer division)\nprint(f\"Modulus: {a % b}\")         # 1 (remainder)\nprint(f\"Exponentiation: {a ** b}\") # 1000 (10^3)\n```\n\nüí° **Comparison Operators**\n\nThese operators return Boolean values (True/False):\n\n```python\nx = 5\ny = 8\n\nprint(f\"{x} == {y}: {x == y}\")  # False (equal)\nprint(f\"{x} != {y}: {x != y}\")  # True (not equal)\nprint(f\"{x} < {y}: {x < y}\")    # True (less than)\nprint(f\"{x} > {y}: {x > y}\")    # False (greater than)\nprint(f\"{x} <= {y}: {x <= y}\")  # True (less than or equal)\nprint(f\"{x} >= {y}: {x >= y}\")  # False (greater than or equal)\n\n# String comparison\nname1 = \"Alice\"\nname2 = \"Bob\"\nprint(f\"'{name1}' < '{name2}': {name1 < name2}\")  # True (alphabetical)\n```\n\nüîß **Logical Operators**\n\nCombine multiple conditions using logical operators:\n\n```python\nage = 25\nis_student = True\nhas_job = False\n\n# AND operator\ncan_get_discount = age < 30 and is_student\nprint(f\"Can get student discount: {can_get_discount}\")  # True\n\n# OR operator\nneeds_support = not has_job or age < 18\nprint(f\"Needs financial support: {needs_support}\")  # True\n\n# NOT operator\nis_adult = not (age < 18)\nprint(f\"Is adult: {is_adult}\")  # True\n```\n\n‚ö†Ô∏è **Operator Precedence**\n\nPython follows mathematical order of operations:\n\n```python\n# Without parentheses\nresult1 = 2 + 3 * 4    # 14 (multiplication first)\n\n# With parentheses\nresult2 = (2 + 3) * 4  # 20 (addition first)\n\n# Complex expression\ncomplex_calc = 2 ** 3 + 4 * 5 - 6 // 2\nprint(f\"Result: {complex_calc}\")  # 25\n# Order: 2¬≥=8, 4√ó5=20, 6//2=3, then 8+20-3=25\n```\n\nüíé **Practical Example: Grade Calculator**\n```python\n# Input grades\nmidterm = float(input(\"Midterm grade: \"))\nfinal = float(input(\"Final grade: \"))\nhomework = float(input(\"Homework average: \"))\n\n# Calculate weighted average\ntotal = midterm * 0.3 + final * 0.4 + homework * 0.3\n\n# Determine letter grade\npassed = total >= 60\nletter = \"A\" if total >= 90 else \"B\" if total >= 80 else \"C\" if total >= 70 else \"D\" if total >= 60 else \"F\"\n\nprint(f\"Final grade: {total:.1f} ({letter})\")\nprint(f\"Status: {'PASSED' if passed else 'FAILED'}\")\n```"
      }
    ]
  },
  "2": {
    "sections": [
      {
        "title": "Conditional Statements",
        "content": "### Conditional Statements\n\nConditional statements enable your programs to make decisions and execute different code paths based on specific conditions. Python uses **if**, **elif**, and **else** statements to implement decision-making logic.\n\n#### Basic If Statement\n\n```python\nage = 18\nif age >= 18:\n    print(\"You can vote!\")\n```\n\n#### If-Elif-Else Chain\n\nUse **elif** (else if) for multiple conditions and **else** for default cases:\n\n```python\nscore = 85\nif score >= 90:\n    grade = 'A'\nelif score >= 80:\n    grade = 'B'\nelif score >= 70:\n    grade = 'C'\nelse:\n    grade = 'F'\nprint(f\"Your grade is: {grade}\")\n```\n\n#### Comparison Operators\n\n| Operator | Description | Example |\n|----------|-------------|----------|\n| `==` | Equal to | `x == 5` |\n| `!=` | Not equal to | `x != 5` |\n| `<` | Less than | `x < 10` |\n| `<=` | Less than or equal | `x <= 10` |\n| `>` | Greater than | `x > 0` |\n| `>=` | Greater than or equal | `x >= 0` |\n\n#### Logical Operators\n\nCombine conditions using **and**, **or**, and **not**:\n\n```python\ntemperature = 25\nweather = \"sunny\"\n\nif temperature > 20 and weather == \"sunny\":\n    print(\"Perfect day for a picnic!\")\n\nif temperature < 0 or weather == \"stormy\":\n    print(\"Stay indoors today\")\n\nif not weather == \"rainy\":\n    print(\"No umbrella needed\")\n```\n\n#### Practical Example: User Authentication\n\n```python\nusername = input(\"Enter username: \")\npassword = input(\"Enter password: \")\n\nif username == \"admin\" and password == \"secret123\":\n    print(\"‚úÖ Login successful!\")\nelif username == \"admin\":\n    print(\"‚ö†Ô∏è Incorrect password\")\nelse:\n    print(\"‚ö†Ô∏è User not found\")\n```\n\nüéì **Key Insight**: Always consider the order of conditions in elif chains - Python evaluates them sequentially and stops at the first true condition.\n\nüí° **Tip**: Use parentheses to make complex logical expressions more readable: `if (age >= 18) and (has_license or has_permit):`"
      },
      {
        "title": "Loops and Iteration",
        "content": "### Loops and Iteration\n\nLoops allow you to repeat code execution, making programs more efficient and capable of processing large amounts of data. Python provides **for** loops for iterating over sequences and **while** loops for condition-based repetition.\n\n#### For Loops\n\nIterate over sequences like lists, strings, or ranges:\n\n```python\n# Iterate over a list\nfruits = [\"apple\", \"banana\", \"orange\"]\nfor fruit in fruits:\n    print(f\"I love {fruit}!\")\n\n# Iterate over a range\nfor i in range(5):\n    print(f\"Count: {i}\")\n\n# Iterate with index\nfor index, fruit in enumerate(fruits):\n    print(f\"{index}: {fruit}\")\n```\n\n#### While Loops\n\nRepeat code while a condition remains true:\n\n```python\ncount = 0\nwhile count < 5:\n    print(f\"Counter: {count}\")\n    count += 1  # Important: update the condition variable\n\n# User input validation\nwhile True:\n    user_input = input(\"Enter 'quit' to exit: \")\n    if user_input.lower() == 'quit':\n        break\n    print(f\"You entered: {user_input}\")\n```\n\n#### Loop Control Statements\n\n- **break**: Exit the loop immediately\n- **continue**: Skip the rest of the current iteration\n\n```python\n# Finding the first even number\nnumbers = [1, 3, 4, 7, 8, 9]\nfor num in numbers:\n    if num % 2 == 0:\n        print(f\"First even number: {num}\")\n        break\n\n# Skip odd numbers\nfor num in range(10):\n    if num % 2 != 0:\n        continue\n    print(f\"Even number: {num}\")\n```\n\n#### Practical Example: Data Processing\n\n```python\n# Calculate average of positive numbers\nnumbers = [10, -5, 8, -2, 15, 3]\npositive_sum = 0\npositive_count = 0\n\nfor num in numbers:\n    if num > 0:\n        positive_sum += num\n        positive_count += 1\n\nif positive_count > 0:\n    average = positive_sum / positive_count\n    print(f\"Average of positive numbers: {average:.2f}\")\nelse:\n    print(\"No positive numbers found\")\n```\n\n‚ö†Ô∏è **Warning**: Always ensure while loops have a way to terminate to avoid infinite loops.\n\nüîß **Best Practice**: Use for loops when you know the number of iterations; use while loops for condition-based repetition."
      },
      {
        "title": "Function Definition and Usage",
        "content": "### Function Definition and Usage\n\nFunctions are reusable blocks of code that perform specific tasks. They help organize code, reduce repetition, and make programs more modular and maintainable.\n\n#### Basic Function Definition\n\nUse the **def** keyword to create functions:\n\n```python\ndef greet():\n    print(\"Hello, World!\")\n\n# Call the function\ngreet()  # Output: Hello, World!\n```\n\n#### Functions with Parameters\n\nMake functions flexible by accepting input parameters:\n\n```python\ndef greet_person(name, age):\n    print(f\"Hello {name}, you are {age} years old!\")\n\n# Call with arguments\ngreet_person(\"Alice\", 25)\ngreet_person(\"Bob\", 30)\n```\n\n#### Default Parameters\n\nProvide default values for parameters:\n\n```python\ndef create_profile(name, age, city=\"Unknown\"):\n    return f\"{name}, {age} years old, from {city}\"\n\nprint(create_profile(\"John\", 28))\nprint(create_profile(\"Sarah\", 32, \"New York\"))\n```\n\n#### Return Values\n\nFunctions can return values using the **return** statement:\n\n```python\ndef calculate_area(length, width):\n    area = length * width\n    return area\n\ndef get_user_info():\n    name = input(\"Enter your name: \")\n    age = int(input(\"Enter your age: \"))\n    return name, age  # Return multiple values as tuple\n\n# Using return values\nrectangle_area = calculate_area(5, 3)\nprint(f\"Area: {rectangle_area}\")\n\nuser_name, user_age = get_user_info()\nprint(f\"Welcome {user_name}, age {user_age}!\")\n```\n\n#### Practical Example: Temperature Converter\n\n```python\ndef celsius_to_fahrenheit(celsius):\n    \"\"\"Convert Celsius to Fahrenheit.\"\"\"\n    fahrenheit = (celsius * 9/5) + 32\n    return fahrenheit\n\ndef fahrenheit_to_celsius(fahrenheit):\n    \"\"\"Convert Fahrenheit to Celsius.\"\"\"\n    celsius = (fahrenheit - 32) * 5/9\n    return celsius\n\ndef temperature_converter():\n    \"\"\"Interactive temperature converter.\"\"\"\n    temp = float(input(\"Enter temperature: \"))\n    unit = input(\"Enter unit (C/F): \").upper()\n    \n    if unit == 'C':\n        result = celsius_to_fahrenheit(temp)\n        print(f\"{temp}¬∞C = {result:.1f}¬∞F\")\n    elif unit == 'F':\n        result = fahrenheit_to_celsius(temp)\n        print(f\"{temp}¬∞F = {result:.1f}¬∞C\")\n    else:\n        print(\"Invalid unit!\")\n\n# Use the converter\ntemperature_converter()\n```\n\nüí° **Tip**: Use docstrings (triple quotes) to document what your functions do.\n\n‚úÖ **Good Practice**: Keep functions focused on a single task for better reusability and testing."
      },
      {
        "title": "Scope and Local Variables",
        "content": "### Scope and Local Variables\n\nVariable scope determines where variables can be accessed in your code. Understanding scope is crucial for avoiding bugs and writing maintainable functions.\n\n#### Local vs Global Scope\n\n**Local variables** exist only within the function where they're defined:\n\n```python\ndef my_function():\n    local_var = \"I'm local!\"\n    print(local_var)\n\nmy_function()  # Works fine\n# print(local_var)  # Error! local_var doesn't exist outside the function\n```\n\n**Global variables** exist throughout the entire program:\n\n```python\nglobal_var = \"I'm global!\"\n\ndef show_global():\n    print(global_var)  # Can access global variables\n\ndef show_local():\n    local_var = \"I'm local!\"\n    print(local_var)\n    print(global_var)  # Can also access global variables\n\nshow_global()  # Output: I'm global!\nshow_local()   # Output: I'm local! \\n I'm global!\nprint(global_var)  # Output: I'm global!\n```\n\n#### The Global Keyword\n\nTo modify global variables inside functions, use the **global** keyword:\n\n```python\ncounter = 0  # Global variable\n\ndef increment():\n    global counter\n    counter += 1  # Modify the global variable\n\ndef get_counter():\n    return counter  # Read global variable (no 'global' needed)\n\nprint(f\"Initial: {counter}\")  # Output: 0\nincrement()\nprint(f\"After increment: {counter}\")  # Output: 1\n```\n\n#### Variable Shadowing\n\nLocal variables can \"shadow\" (hide) global variables with the same name:\n\n```python\nname = \"Global Alice\"\n\ndef greet():\n    name = \"Local Bob\"  # This shadows the global 'name'\n    print(f\"Hello, {name}!\")\n\ndef greet_global():\n    print(f\"Hello, {name}!\")  # Uses global 'name'\n\ngreet()         # Output: Hello, Local Bob!\ngreet_global()  # Output: Hello, Global Alice!\nprint(name)     # Output: Global Alice\n```\n\n#### Practical Example: Bank Account\n\n```python\nbalance = 1000  # Global account balance\n\ndef deposit(amount):\n    global balance\n    if amount > 0:\n        balance += amount\n        return f\"Deposited ${amount}. New balance: ${balance}\"\n    return \"Invalid deposit amount\"\n\ndef withdraw(amount):\n    global balance\n    if amount > 0 and amount <= balance:\n        balance -= amount\n        return f\"Withdrew ${amount}. New balance: ${balance}\"\n    return \"Insufficient funds or invalid amount\"\n\ndef check_balance():\n    return f\"Current balance: ${balance}\"\n\n# Usage\nprint(check_balance())  # Current balance: $1000\nprint(deposit(250))     # Deposited $250. New balance: $1250\nprint(withdraw(100))    # Withdrew $100. New balance: $1150\n```\n\n‚ö†Ô∏è **Warning**: Overusing global variables can make code hard to debug and maintain.\n\nüíé **Best Practice**: Prefer passing parameters and returning values instead of using global variables when possible."
      },
      {
        "title": "Control Flow Best Practices",
        "content": "### Control Flow Best Practices\n\nWriting clean, readable control flow structures is essential for professional Python development. These practices improve code maintainability and reduce bugs.\n\n#### Conditional Statement Best Practices\n\n**Use clear, descriptive conditions:**\n\n```python\n# ‚ùå Poor: Unclear logic\nif x > 0 and x < 100 and y:\n    do_something()\n\n# ‚úÖ Better: Clear variable names and logic\nis_valid_score = 0 < score < 100\nhas_permission = user.is_authenticated\n\nif is_valid_score and has_permission:\n    process_score(score)\n```\n\n**Avoid deeply nested conditions:**\n\n```python\n# ‚ùå Poor: Deep nesting\ndef process_user(user):\n    if user is not None:\n        if user.is_active:\n            if user.has_permission:\n                return user.process()\n            else:\n                return \"No permission\"\n        else:\n            return \"User inactive\"\n    else:\n        return \"User not found\"\n\n# ‚úÖ Better: Early returns\ndef process_user(user):\n    if user is None:\n        return \"User not found\"\n    if not user.is_active:\n        return \"User inactive\"\n    if not user.has_permission:\n        return \"No permission\"\n    return user.process()\n```\n\n#### Loop Best Practices\n\n**Choose the right loop type:**\n\n```python\n# ‚úÖ Use for loops for known iterations\nfor i in range(len(items)):\n    process_item(items[i])\n\n# ‚úÖ Even better: iterate directly\nfor item in items:\n    process_item(item)\n\n# ‚úÖ Use while loops for condition-based iteration\nwhile not connection.is_ready():\n    time.sleep(0.1)\n```\n\n**Avoid infinite loops:**\n\n```python\n# ‚ùå Dangerous: Potential infinite loop\nwhile True:\n    data = get_data()\n    if data:\n        process(data)\n    # Missing break condition!\n\n# ‚úÖ Safe: Clear exit condition\nmax_attempts = 10\nattempts = 0\nwhile attempts < max_attempts:\n    data = get_data()\n    if data:\n        process(data)\n        break\n    attempts += 1\n    time.sleep(1)\n```\n\n#### Function Best Practices\n\n**Keep functions focused and small:**\n\n```python\n# ‚úÖ Good: Single responsibility\ndef calculate_tax(amount, rate):\n    \"\"\"Calculate tax for a given amount and rate.\"\"\"\n    return amount * rate\n\ndef format_currency(amount):\n    \"\"\"Format amount as currency string.\"\"\"\n    return f\"${amount:.2f}\"\n\ndef display_total_with_tax(amount, tax_rate):\n    \"\"\"Display formatted total including tax.\"\"\"\n    tax = calculate_tax(amount, tax_rate)\n    total = amount + tax\n    print(f\"Subtotal: {format_currency(amount)}\")\n    print(f\"Tax: {format_currency(tax)}\")\n    print(f\"Total: {format_currency(total)}\")\n```\n\n**Use type hints for clarity:**\n\n```python\ndef calculate_discount(price: float, discount_percent: int) -> float:\n    \"\"\"Calculate discounted price.\n    \n    Args:\n        price: Original price\n        discount_percent: Discount percentage (0-100)\n    \n    Returns:\n        Discounted price\n    \"\"\"\n    return price * (1 - discount_percent / 100)\n```\n\nüéì **Professional Tip**: Use consistent indentation (4 spaces) and meaningful variable names.\n\nüí° **Code Review**: Always ask \"Can someone else easily understand this code?\" when writing control structures.\n\nüîß **Tool Recommendation**: Use linters like `pylint` or `black` to automatically enforce coding standards."
      }
    ]
  },
  "3": {
    "sections": [
      {
        "title": "Lists and List Operations",
        "content": "### Lists and List Operations\n\nLists are Python's most versatile data structure, allowing you to store ordered collections of items that can be modified after creation. Think of lists as dynamic arrays that can grow and shrink as needed.\n\n**Creating and Accessing Lists**\n\n```python\n# Creating lists\nfruits = ['apple', 'banana', 'orange']\nnumbers = [1, 2, 3, 4, 5]\nmixed = ['hello', 42, True, 3.14]\n\n# Accessing elements (zero-indexed)\nprint(fruits[0])     # 'apple'\nprint(fruits[-1])    # 'orange' (last item)\nprint(fruits[0:2])   # ['apple', 'banana'] (slicing)\n```\n\n**Essential List Operations**\n\n```python\n# Adding elements\nfruits.append('grape')           # Add to end\nfruits.insert(1, 'kiwi')        # Insert at position\nfruits.extend(['mango', 'lime']) # Add multiple items\n\n# Removing elements\nfruits.remove('banana')  # Remove by value\npopped = fruits.pop()    # Remove and return last item\ndel fruits[0]           # Remove by index\n\n# Other useful operations\nprint(len(fruits))      # Get length\nprint('apple' in fruits) # Check membership\nfruits.sort()           # Sort in place\nreversed_fruits = fruits[::-1]  # Create reversed copy\n```\n\nüí° **Professional Tip**: Use list comprehensions for efficient data processing:\n```python\nsquares = [x**2 for x in range(10)]\neven_numbers = [x for x in range(20) if x % 2 == 0]\n```\n\nüéì **Best Practices**:\n- Use meaningful variable names: `student_grades` instead of `list1`\n- Prefer `append()` over `insert(0, item)` for performance\n- Use `enumerate()` when you need both index and value in loops\n\n‚ö†Ô∏è **Common Pitfall**: Remember that lists are mutable - changes affect all references to the same list object."
      },
      {
        "title": "Dictionaries and Key-Value Pairs",
        "content": "### Dictionaries and Key-Value Pairs\n\nDictionaries are Python's implementation of hash tables, storing data as key-value pairs. They're perfect for representing structured data and creating fast lookups by meaningful identifiers.\n\n**Creating and Accessing Dictionaries**\n\n```python\n# Creating dictionaries\nstudent = {\n    'name': 'Alice Johnson',\n    'age': 22,\n    'major': 'Computer Science',\n    'gpa': 3.8\n}\n\n# Accessing values\nprint(student['name'])           # 'Alice Johnson'\nprint(student.get('age', 0))     # 22 (safe access)\nprint(student.get('phone', 'N/A')) # 'N/A' (default value)\n```\n\n**Dictionary Operations**\n\n```python\n# Adding and modifying\nstudent['email'] = 'alice@university.edu'\nstudent['gpa'] = 3.9  # Update existing key\n\n# Removing items\ndel student['age']              # Remove key-value pair\nemail = student.pop('email')    # Remove and return value\nstudent.clear()                 # Remove all items\n\n# Useful methods\nprint(student.keys())    # Get all keys\nprint(student.values())  # Get all values\nprint(student.items())   # Get key-value pairs\n```\n\n**Advanced Dictionary Techniques**\n\n```python\n# Dictionary comprehension\nscores = {'math': 95, 'english': 87, 'science': 92}\nletter_grades = {subject: 'A' if score >= 90 else 'B' \n                for subject, score in scores.items()}\n\n# Merging dictionaries (Python 3.9+)\ndefaults = {'theme': 'light', 'notifications': True}\nuser_prefs = {'theme': 'dark'}\nsettings = defaults | user_prefs  # {'theme': 'dark', 'notifications': True}\n```\n\nüîß **Real-World Example**: Processing user data\n```python\nusers = [\n    {'id': 1, 'name': 'John', 'role': 'admin'},\n    {'id': 2, 'name': 'Jane', 'role': 'user'}\n]\nadmins = [user for user in users if user['role'] == 'admin']\n```\n\nüíé **Performance Note**: Dictionary lookups are O(1) average case, making them ideal for frequent data retrieval operations."
      },
      {
        "title": "Tuples and Immutable Data",
        "content": "### Tuples and Immutable Data\n\nTuples are immutable sequences that store related data together. Once created, tuples cannot be modified, making them perfect for representing fixed collections like coordinates, database records, or configuration settings.\n\n**Creating and Using Tuples**\n\n```python\n# Creating tuples\npoint = (10, 20)                    # 2D coordinate\nrgb_color = (255, 128, 0)          # RGB values\nperson = ('Alice', 25, 'Engineer')  # Name, age, profession\n\n# Accessing elements\nprint(point[0])        # 10\nprint(person[-1])      # 'Engineer'\nx, y = point          # Tuple unpacking\nname, age, job = person\n```\n\n**When to Use Tuples vs Lists**\n\n| Use Tuples When: | Use Lists When: |\n|------------------|----------------|\n| Data won't change | Data needs modification |\n| Representing records | Building collections |\n| Dictionary keys | Order matters for operations |\n| Function returns multiple values | Processing sequences |\n\n**Advanced Tuple Operations**\n\n```python\n# Named tuples for better readability\nfrom collections import namedtuple\n\nStudent = namedtuple('Student', ['name', 'grade', 'major'])\nalice = Student('Alice Johnson', 3.8, 'CS')\nprint(alice.name)     # More readable than alice[0]\nprint(alice.grade)    # alice.grade instead of alice[1]\n\n# Tuple methods\nnumbers = (1, 2, 3, 2, 2, 4)\nprint(numbers.count(2))  # 3 (how many times 2 appears)\nprint(numbers.index(3))  # 2 (position of first 3)\n```\n\n**Practical Applications**\n\n```python\n# Function returning multiple values\ndef get_user_info():\n    return 'John Doe', 30, 'john@email.com'\n\nname, age, email = get_user_info()  # Clean unpacking\n\n# Database-like records\nemployees = [\n    ('E001', 'Alice', 'Engineering', 75000),\n    ('E002', 'Bob', 'Marketing', 65000),\n    ('E003', 'Carol', 'Sales', 55000)\n]\n\n# Processing records\nfor emp_id, name, dept, salary in employees:\n    if salary > 60000:\n        print(f'{name} in {dept}: ${salary:,}')\n```\n\n‚úÖ **Memory Advantage**: Tuples use less memory than lists and are faster for fixed-size collections."
      },
      {
        "title": "File Reading and Writing",
        "content": "### File Reading and Writing\n\nFile operations enable data persistence, allowing your programs to save results and load data between sessions. Python provides intuitive methods for handling various file formats and operations.\n\n**Reading Files**\n\n```python\n# Reading entire file\nwith open('data.txt', 'r') as file:\n    content = file.read()        # Read entire file\n    print(content)\n\n# Reading line by line\nwith open('data.txt', 'r') as file:\n    lines = file.readlines()     # List of all lines\n    for line in lines:\n        print(line.strip())      # Remove newline characters\n\n# Memory-efficient reading for large files\nwith open('large_file.txt', 'r') as file:\n    for line in file:            # Process one line at a time\n        # Process line without loading entire file\n        processed_data = line.strip().upper()\n```\n\n**Writing Files**\n\n```python\n# Writing text files\ndata = ['apple', 'banana', 'cherry']\n\nwith open('fruits.txt', 'w') as file:\n    file.write('My favorite fruits:\\n')\n    for fruit in data:\n        file.write(f'- {fruit}\\n')\n\n# Appending to files\nwith open('log.txt', 'a') as file:\n    file.write(f'Entry at {datetime.now()}\\n')\n```\n\n**Working with CSV Files**\n\n```python\nimport csv\n\n# Writing CSV\nemployees = [\n    ['Name', 'Department', 'Salary'],\n    ['Alice', 'Engineering', 75000],\n    ['Bob', 'Marketing', 65000]\n]\n\nwith open('employees.csv', 'w', newline='') as file:\n    writer = csv.writer(file)\n    writer.writerows(employees)\n\n# Reading CSV\nwith open('employees.csv', 'r') as file:\n    reader = csv.reader(file)\n    header = next(reader)  # Skip header row\n    for row in reader:\n        name, dept, salary = row\n        print(f'{name}: ${int(salary):,}')\n```\n\n**Error Handling and Best Practices**\n\n```python\ntry:\n    with open('config.json', 'r') as file:\n        import json\n        config = json.load(file)\nexcept FileNotFoundError:\n    print('Config file not found, using defaults')\n    config = {'theme': 'light', 'debug': False}\nexcept json.JSONDecodeError:\n    print('Invalid JSON format in config file')\n```\n\n‚ö†Ô∏è **Always use `with` statements** - they automatically close files even if errors occur, preventing resource leaks.\n\nüîß **File Modes Reference**:\n- `'r'`: Read (default)\n- `'w'`: Write (overwrites existing)\n- `'a'`: Append\n- `'r+'`: Read and write"
      },
      {
        "title": "Data Processing Patterns",
        "content": "### Data Processing Patterns\n\nMastering common data processing patterns enables you to efficiently manipulate, filter, and transform data using Python's built-in data structures. These patterns form the foundation of data analysis and application development.\n\n**Filtering and Mapping Patterns**\n\n```python\n# Sample dataset\nsales_data = [\n    {'product': 'Laptop', 'price': 999, 'quantity': 5, 'category': 'Electronics'},\n    {'product': 'Book', 'price': 15, 'quantity': 50, 'category': 'Education'},\n    {'product': 'Phone', 'price': 699, 'quantity': 10, 'category': 'Electronics'},\n    {'product': 'Pen', 'price': 2, 'quantity': 100, 'category': 'Office'}\n]\n\n# Filtering patterns\nhigh_value_items = [item for item in sales_data if item['price'] > 100]\nelectronics = list(filter(lambda x: x['category'] == 'Electronics', sales_data))\n\n# Mapping/transformation patterns\ntotal_values = [item['price'] * item['quantity'] for item in sales_data]\nproduct_names = list(map(lambda x: x['product'].upper(), sales_data))\n```\n\n**Aggregation and Grouping**\n\n```python\n# Calculate totals\ntotal_revenue = sum(item['price'] * item['quantity'] for item in sales_data)\naverage_price = sum(item['price'] for item in sales_data) / len(sales_data)\n\n# Grouping by category\nfrom collections import defaultdict\n\ncategory_totals = defaultdict(float)\nfor item in sales_data:\n    category_totals[item['category']] += item['price'] * item['quantity']\n\n# Convert to regular dict for display\ncategory_summary = dict(category_totals)\nprint(category_summary)  # {'Electronics': 11985, 'Education': 750, 'Office': 200}\n```\n\n**Data Validation and Cleaning**\n\n```python\n# Cleaning and validating data\ndef clean_sales_data(data):\n    cleaned = []\n    for item in data:\n        # Skip items with missing or invalid data\n        if not all(key in item for key in ['product', 'price', 'quantity']):\n            continue\n        if item['price'] <= 0 or item['quantity'] <= 0:\n            continue\n            \n        # Clean and standardize\n        cleaned_item = {\n            'product': item['product'].strip().title(),\n            'price': round(float(item['price']), 2),\n            'quantity': int(item['quantity']),\n            'category': item.get('category', 'Unknown').title()\n        }\n        cleaned.append(cleaned_item)\n    return cleaned\n```\n\n**File Processing Pipeline**\n\n```python\n# Complete data processing workflow\ndef process_sales_file(filename):\n    # Read data\n    with open(filename, 'r') as file:\n        import json\n        raw_data = json.load(file)\n    \n    # Clean and filter\n    clean_data = clean_sales_data(raw_data)\n    high_value = [item for item in clean_data if item['price'] * item['quantity'] > 500]\n    \n    # Generate report\n    report = {\n        'total_items': len(clean_data),\n        'high_value_items': len(high_value),\n        'category_breakdown': dict(category_totals)\n    }\n    \n    # Save results\n    with open('sales_report.json', 'w') as file:\n        json.dump(report, file, indent=2)\n    \n    return report\n```\n\nüí° **Performance Tip**: Use generator expressions for large datasets to save memory:\n```python\ntotal = sum(item['price'] for item in large_dataset)  # Memory efficient\n```"
      }
    ]
  }
};
